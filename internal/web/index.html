<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>jq-view</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg-primary: #1a1d24;
      --bg-secondary: #22262e;
      --bg-tertiary: #2a2f38;
      --bg-hover: #353b45;
      --bg-active: #00d4ff18;
      --border: #3d4450;
      --border-muted: #2e333c;
      --text-primary: #f0f4f8;
      --text-secondary: #a8b5c4;
      --text-muted: #7a8999;
      --accent: #00d4ff;
      --accent-glow: #00d4ff50;
      --green: #00ff9f;
      --green-muted: #00cc7a;
      --orange: #ffaa00;
      --purple: #bf7fff;
      --red: #ff5c5c;
      --cyan: #00e5ff;
      --pink: #ff6ec7;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
      font-size: 15px;
      line-height: 1.5;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
      border-bottom: 1px solid var(--border);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      font-size: 16px;
      color: var(--text-primary);
    }

    .brand-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--cyan) 0%, var(--purple) 50%, var(--pink) 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 25px var(--accent-glow);
    }

    .brand-icon svg {
      fill: #fff;
    }

    .actions {
      display: flex;
      gap: 8px;
    }

    .btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 7px 18px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .btn:hover {
      background: var(--bg-hover);
      border-color: var(--text-muted);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--green) 0%, var(--cyan) 100%);
      border-color: var(--green-muted);
      color: #000;
      font-weight: 600;
      box-shadow: 0 0 15px #00ff9f40;
    }
    .btn-primary:hover {
      box-shadow: 0 0 25px #00ff9f60;
    }

    select.btn {
      appearance: none;
      padding-right: 28px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%238b949e'%3E%3Cpath d='M4.427 7.427l3.396 3.396a.25.25 0 00.354 0l3.396-3.396A.25.25 0 0011.396 7H4.604a.25.25 0 00-.177.427z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    /* Main */
    .main {
      flex: 1;
      display: grid;
      grid-template-columns: 420px 1fr;
      overflow: hidden;
    }

    .sidebar {
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--bg-secondary);
    }

    .sidebar-header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
    }

    .sidebar-actions {
      display: flex;
      gap: 16px;
    }

    .sidebar-actions span {
      cursor: pointer;
      color: var(--accent);
      font-weight: 500;
      text-transform: none;
      letter-spacing: 0;
      font-size: 13px;
    }

    .sidebar-actions span:hover {
      text-decoration: underline;
      text-shadow: 0 0 10px var(--accent-glow);
    }

    .sidebar-actions span.active {
      color: var(--green);
      text-shadow: 0 0 10px #00ff9f50;
    }

    .tree-container {
      flex: 1;
      overflow: auto;
      padding: 8px 0;
    }

    /* Tree */
    .tree-node {
      user-select: none;
    }

    .tree-row {
      display: flex;
      align-items: center;
      padding: 6px 16px 6px 0;
      cursor: pointer;
      transition: all 0.15s;
      border-radius: 4px;
      margin: 1px 8px;
      border: 1px solid transparent;
    }

    .tree-row:hover {
      background: var(--bg-hover);
    }

    .tree-row.selected {
      background: var(--bg-active);
      border-color: var(--accent);
      box-shadow: 0 0 10px var(--accent-glow);
    }

    .tree-row.dragging {
      opacity: 0.5;
    }

    .tree-row.drag-over {
      border-top: 2px solid var(--accent);
      margin-top: 0;
    }

    .tree-row.drag-over-bottom {
      border-bottom: 2px solid var(--accent);
      margin-bottom: 0;
    }

    .tree-row.drag-over-into {
      background: var(--accent-glow);
      border: 2px dashed var(--accent);
      box-shadow: 0 0 15px var(--accent-glow);
    }

    .tree-row.drag-over-into .tree-icon {
      transform: scale(1.2);
      transition: transform 0.15s;
    }

    .drag-handle {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      cursor: grab;
      margin-right: 4px;
      opacity: 0.5;
      transition: opacity 0.15s;
    }

    .tree-row:hover .drag-handle {
      opacity: 1;
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    .tree-toggle {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      font-size: 11px;
      flex-shrink: 0;
      margin-right: 4px;
      transition: color 0.15s;
    }

    .tree-toggle:hover { color: var(--accent); }

    .tree-checkbox {
      width: 17px;
      height: 17px;
      margin-right: 8px;
      accent-color: var(--accent);
      flex-shrink: 0;
      cursor: pointer;
    }

    .tree-icon {
      width: 22px;
      height: 22px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      font-size: 10px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .tree-icon.obj {
      background: linear-gradient(135deg, #ffaa0040 0%, #ffaa0015 100%);
      color: var(--orange);
      border: 1px solid #ffaa0050;
    }
    .tree-icon.arr {
      background: linear-gradient(135deg, #bf7fff40 0%, #bf7fff15 100%);
      color: var(--purple);
      border: 1px solid #bf7fff50;
    }

    .tree-key {
      font-weight: 600;
      color: var(--text-primary);
      margin-right: 8px;
    }

    .tree-type {
      color: var(--text-muted);
      font-size: 13px;
      font-weight: 400;
    }

    .tree-value {
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, monospace;
      font-size: 13px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 150px;
    }

    .tree-value.str { color: var(--cyan); }
    .tree-value.num { color: var(--purple); }
    .tree-value.bool { color: var(--orange); }
    .tree-value.null { color: var(--text-muted); font-style: italic; }

    /* Output */
    .output {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--bg-primary);
    }

    .output-header {
      padding: 14px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .output-title {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
    }

    .output-badge {
      font-size: 12px;
      padding: 3px 12px;
      border-radius: 12px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--purple) 100%);
      color: #000;
      font-weight: 600;
      border: none;
      box-shadow: 0 0 12px var(--accent-glow);
    }

    .output-content {
      flex: 1;
      overflow: auto;
      padding: 16px;
      margin: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .output-content pre {
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, monospace;
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-primary);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .output-content pre.error {
      color: var(--red);
    }

    /* Footer */
    .footer {
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .jq-label {
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, monospace;
      font-size: 14px;
      font-weight: 700;
      color: #000;
      background: linear-gradient(135deg, var(--purple) 0%, var(--pink) 100%);
      padding: 7px 14px;
      border-radius: 6px;
      border: none;
      box-shadow: 0 0 15px #bf7fff40;
    }

    .jq-input {
      flex: 1;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 9px 14px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, monospace;
      font-size: 14px;
      transition: all 0.2s;
    }

    .jq-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-glow), 0 0 20px var(--accent-glow);
    }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }
    ::-webkit-scrollbar-thumb {
      background: var(--bg-hover);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }
  </style>
</head>
<body>
  <div id="app" class="app">
    <div class="header">
      <div class="brand">
        <div class="brand-icon">
          <svg height="24" viewBox="0 0 16 16" width="24"><path fill="#fff" d="M8.5 1.75a.75.75 0 00-1.5 0V5H4a.75.75 0 000 1.5h3v3.25a.75.75 0 001.5 0V6.5H12A.75.75 0 0012 5H8.5V1.75z"/><path fill="#fff" d="M5 9.5a.75.75 0 01.75.75v2.25h2.5a.75.75 0 010 1.5h-3.5a.75.75 0 01-.75-.75v-3a.75.75 0 01.75-.75z"/></svg>
        </div>
        <span>jq-view</span>
      </div>
      <div class="actions">
        <select class="btn" v-model="format">
          <option value="json">JSON</option>
          <option value="table">Table</option>
        </select>
        <button class="btn" @click="copyResult">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
          Copy
        </button>
      </div>
    </div>

    <div class="main">
      <div class="sidebar">
        <div class="sidebar-header">
          <span>Fields</span>
          <div class="sidebar-actions">
            <span @click="dragEnabled = !dragEnabled" :class="{ active: dragEnabled }">{{ dragEnabled ? 'Drag On' : 'Drag' }}</span>
            <span @click="expandAll">Expand</span>
            <span @click="collapseAll">Collapse</span>
          </div>
        </div>
        <div class="tree-container">
          <tree-node
            v-if="tree"
            :node="tree"
            :depth="0"
            :index="0"
            :parent-children="null"
            :drag-enabled="dragEnabled"
            @toggle="toggleNode"
            @select="selectNode"
            @reorder="handleReorder"
            @move-into="handleMoveInto"
          />
        </div>
      </div>

      <div class="output">
        <div class="output-header">
          <span class="output-title">Output</span>
          <span class="output-badge">{{ format.toUpperCase() }}</span>
        </div>
        <div class="output-content">
          <pre :class="{ error: !!error }">{{ error || result }}</pre>
        </div>
      </div>
    </div>

    <div class="footer">
      <span class="jq-label">jq</span>
      <input
        class="jq-input"
        v-model="expression"
        @keyup.enter="runQuery"
        placeholder="Enter jq expression..."
      >
      <button class="btn btn-primary" @click="runQuery">Run</button>
    </div>
  </div>

  <script>
    const { createApp, ref, watch, onMounted, nextTick } = Vue;

    const TreeNode = {
      name: 'TreeNode',
      props: ['node', 'depth', 'index', 'parentChildren', 'dragEnabled'],
      emits: ['toggle', 'select', 'reorder', 'move-into'],
      template: `
        <div class="tree-node">
          <div
            class="tree-row"
            :class="{ selected: node.selected, dragging: isDragging, 'drag-over': isDragOver, 'drag-over-bottom': isDragOverBottom, 'drag-over-into': isDragOverInto }"
            :style="{ paddingLeft: depth * 20 + 12 + 'px' }"
            :draggable="dragEnabled && parentChildren !== null"
            @click="handleClick"
            @dragstart="onDragStart"
            @dragend="onDragEnd"
            @dragover="onDragOver"
            @dragleave="onDragLeave"
            @drop="onDrop"
          >
            <span v-if="dragEnabled && parentChildren !== null" class="drag-handle" @mousedown.stop>⋮⋮</span>
            <span class="tree-toggle" @click.stop="$emit('toggle', node)">
              <template v-if="node.children && node.children.length">
                {{ node.expanded ? '▼' : '▶' }}
              </template>
            </span>

            <input
              v-if="node.isLeaf"
              type="checkbox"
              class="tree-checkbox"
              :checked="node.selected"
              @click.stop="$emit('select', node)"
            >
            <span v-else class="tree-icon" :class="node.isArray ? 'arr' : 'obj'">
              {{ node.isArray ? '[ ]' : '{ }' }}
            </span>

            <span class="tree-key">{{ node.key }}</span>

            <span v-if="!node.isLeaf" class="tree-type">
              {{ node.isArray ? node.arrayLength + ' items' : (node.children ? node.children.length : 0) + ' keys' }}
            </span>
          </div>

          <template v-if="node.expanded && node.children">
            <tree-node
              v-for="(child, idx) in node.children"
              :key="child.key + '-' + idx"
              :node="child"
              :depth="depth + 1"
              :index="idx"
              :parent-children="node.children"
              :drag-enabled="dragEnabled"
              @toggle="$emit('toggle', $event)"
              @select="$emit('select', $event)"
              @reorder="$emit('reorder', $event)"
              @move-into="$emit('move-into', $event)"
            />
          </template>
        </div>
      `,
      data() {
        return {
          isDragging: false,
          isDragOver: false,
          isDragOverBottom: false,
          isDragOverInto: false
        };
      },
      methods: {
        handleClick() {
          if (this.node.isLeaf) {
            this.$emit('select', this.node);
          } else {
            this.$emit('toggle', this.node);
          }
        },
        onDragStart(e) {
          if (!this.dragEnabled || this.parentChildren === null) {
            e.preventDefault();
            return;
          }
          this.isDragging = true;
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('application/json', JSON.stringify({
            path: this.node.path,
            key: this.node.key,
            index: this.index
          }));
        },
        onDragEnd() {
          this.isDragging = false;
        },
        onDragOver(e) {
          if (!this.dragEnabled) return;
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          const rect = e.currentTarget.getBoundingClientRect();
          const relY = e.clientY - rect.top;
          const height = rect.height;

          // For container nodes (array/object), check if dropping INTO the center
          const isContainer = !this.node.isLeaf && (this.node.isArray || this.node.children);

          if (isContainer && this.parentChildren !== null) {
            // Divide into 3 zones: top 25% = before, middle 50% = into, bottom 25% = after
            if (relY < height * 0.25) {
              this.isDragOver = true;
              this.isDragOverBottom = false;
              this.isDragOverInto = false;
            } else if (relY > height * 0.75) {
              this.isDragOver = false;
              this.isDragOverBottom = true;
              this.isDragOverInto = false;
            } else {
              this.isDragOver = false;
              this.isDragOverBottom = false;
              this.isDragOverInto = true;
            }
          } else if (isContainer && this.parentChildren === null) {
            // Root-level container can only accept drops INTO
            this.isDragOver = false;
            this.isDragOverBottom = false;
            this.isDragOverInto = true;
          } else if (this.parentChildren !== null) {
            // Leaf nodes: only reorder (top/bottom)
            const midY = rect.top + height / 2;
            if (e.clientY < midY) {
              this.isDragOver = true;
              this.isDragOverBottom = false;
            } else {
              this.isDragOver = false;
              this.isDragOverBottom = true;
            }
            this.isDragOverInto = false;
          }
        },
        onDragLeave(e) {
          // Only clear if leaving the element entirely
          const rect = e.currentTarget.getBoundingClientRect();
          if (e.clientX < rect.left || e.clientX > rect.right ||
              e.clientY < rect.top || e.clientY > rect.bottom) {
            this.isDragOver = false;
            this.isDragOverBottom = false;
            this.isDragOverInto = false;
          }
        },
        onDrop(e) {
          e.preventDefault();
          e.stopPropagation();

          const wasDragOverInto = this.isDragOverInto;
          this.isDragOver = false;
          this.isDragOverBottom = false;
          this.isDragOverInto = false;

          if (!this.dragEnabled) return;

          try {
            const dataStr = e.dataTransfer.getData('application/json');
            if (!dataStr) return;

            const data = JSON.parse(dataStr);
            const fromPath = data.path;
            const fromKey = data.key;
            const toPath = this.node.path;

            if (fromPath === toPath) return;

            // Prevent dropping a parent into its own child
            if (toPath.startsWith(fromPath + '.') || toPath.startsWith(fromPath + '[')) return;

            // If dropping INTO a container
            if (wasDragOverInto && !this.node.isLeaf) {
              this.$emit('move-into', {
                fromPath,
                fromKey,
                targetNode: this.node
              });
              return;
            }

            // Otherwise, reorder within same parent
            if (this.parentChildren === null) return;

            const rect = e.currentTarget.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            const insertAfter = e.clientY >= midY;

            this.$emit('reorder', {
              fromPath,
              toPath,
              insertAfter,
              parentChildren: this.parentChildren
            });
          } catch (err) {
            console.error('Drop error:', err);
          }
        }
      }
    };

    createApp({
      components: { TreeNode },
      setup() {
        const rawData = ref({{INITIAL_DATA}});
        const tree = ref(null);
        const result = ref('');
        const error = ref('');
        const format = ref('json');
        const expression = ref('.');
        const dragEnabled = ref(false);
        // Track moved nodes: { fromPath: string, toPath: string, key: string }[]
        const movedNodes = ref([]);

        function buildTree(data, key = 'root', path = '.', isArrayItem = false, originalIndex = 0) {
          const node = {
            key,
            path,
            value: data,
            expanded: path === '.',
            selected: false,
            isLeaf: false,
            isArray: false,
            isArrayItem,
            arrayLength: 0,
            children: null,
            displayValue: '',
            valueType: '',
            originalIndex
          };

          if (Array.isArray(data)) {
            node.isArray = true;
            node.arrayLength = data.length;
            // Directly show fields from first element (no [*] wrapper)
            if (data.length > 0 && typeof data[0] === 'object') {
              const templatePath = path + '[]';
              node.children = Object.entries(data[0]).map(([k, v], idx) =>
                buildTree(v, k, `${templatePath}.${k}`, true, idx)
              );
            }
          } else if (data && typeof data === 'object') {
            node.children = Object.entries(data).map(([k, v], idx) =>
              buildTree(v, k, path === '.' ? `.${k}` : `${path}.${k}`, isArrayItem, idx)
            );
          } else {
            node.isLeaf = true;
            node.displayValue = formatValue(data);
            node.valueType = getValueType(data);
          }

          return node;
        }

        function formatValue(v) {
          if (v === null) return 'null';
          if (typeof v === 'string') return v.length > 30 ? `"${v.slice(0, 30)}…"` : `"${v}"`;
          if (typeof v === 'boolean') return v ? 'true' : 'false';
          return String(v);
        }

        function getValueType(v) {
          if (v === null) return 'null';
          if (typeof v === 'string') return 'str';
          if (typeof v === 'number') return 'num';
          if (typeof v === 'boolean') return 'bool';
          return '';
        }

        function toggleNode(node) {
          node.expanded = !node.expanded;
        }

        function selectNode(node) {
          node.selected = !node.selected;
          updateExpression();
        }

        function handleReorder({ fromPath, toPath, insertAfter, parentChildren }) {
          const fromIdx = parentChildren.findIndex(c => c.path === fromPath);
          const toIdx = parentChildren.findIndex(c => c.path === toPath);

          if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;

          // Calculate new position
          let newIdx = toIdx;
          if (fromIdx < toIdx) newIdx--;
          if (insertAfter) newIdx++;

          // Perform the move
          const [moved] = parentChildren.splice(fromIdx, 1);
          parentChildren.splice(newIdx, 0, moved);

          // Force Vue to detect the change
          tree.value = { ...tree.value };

          // Immediately update and run query
          const selected = collectSelected(tree.value);
          if (selected.length > 0) {
            expression.value = buildNestedExpr(selected);
          }
          runQuery();
        }

        // Find a node by path in the tree
        function findNodeByPath(node, path) {
          if (node.path === path) return node;
          if (node.children) {
            for (const child of node.children) {
              const found = findNodeByPath(child, path);
              if (found) return found;
            }
          }
          return null;
        }

        // Find the parent node and index of a node by path
        function findParentOfNode(root, targetPath, parent = null, index = -1) {
          if (root.path === targetPath) {
            return { parent, index };
          }
          if (root.children) {
            for (let i = 0; i < root.children.length; i++) {
              const result = findParentOfNode(root.children[i], targetPath, root, i);
              if (result.parent !== null) return result;
            }
          }
          return { parent: null, index: -1 };
        }

        // Update paths recursively when a node is moved
        function updateNodePaths(node, newBasePath) {
          const isArrayContext = newBasePath.includes('[]');
          node.path = newBasePath;
          node.isArrayItem = isArrayContext;

          if (node.children) {
            node.children.forEach(child => {
              const childPath = node.isArray
                ? `${newBasePath}[].${child.key}`
                : `${newBasePath}.${child.key}`;
              updateNodePaths(child, childPath);
            });
          }
        }

        // Handle moving a node INTO a container
        function handleMoveInto({ fromPath, fromKey, targetNode }) {
          // Find source node and its parent
          const sourceNode = findNodeByPath(tree.value, fromPath);
          if (!sourceNode) return;

          const { parent: sourceParent, index: sourceIndex } = findParentOfNode(tree.value, fromPath);
          if (!sourceParent || sourceIndex === -1) return;

          // Don't allow moving into self or own children
          if (targetNode.path === fromPath || targetNode.path.startsWith(fromPath + '.')) return;

          // Remove from source parent
          const [movedNode] = sourceParent.children.splice(sourceIndex, 1);

          // Calculate new path based on target
          let newPath;
          if (targetNode.isArray) {
            // Moving into an array: add as a field to array items
            newPath = `${targetNode.path}[].${movedNode.key}`;
          } else {
            // Moving into an object
            newPath = `${targetNode.path}.${movedNode.key}`;
          }

          // Update the moved node's paths recursively
          updateNodePaths(movedNode, newPath);

          // Record the move for expression building
          movedNodes.value.push({
            fromPath: fromPath,
            toPath: targetNode.path,
            key: movedNode.key,
            originalPath: fromPath  // Keep original for jq source
          });

          // Add to target's children
          if (!targetNode.children) {
            targetNode.children = [];
          }
          targetNode.children.push(movedNode);

          // Expand target to show the moved node
          targetNode.expanded = true;

          // Force Vue to detect the change
          tree.value = { ...tree.value };

          // Update expression if there are selections
          const selected = collectSelected(tree.value);
          if (selected.length > 0) {
            expression.value = buildNestedExpr(selected);
          }
          runQuery();
        }

        function collectSelected(node, paths = [], orderCounter = { value: 0 }) {
          if (node.selected && node.isLeaf) {
            // Check if this node is under a moved parent
            let sourcePath = node.path;
            let isMoved = false;

            for (const move of movedNodes.value) {
              // Check if the node's path starts with the moved node's new path
              const movedNewPathPrefix = move.toPath.endsWith('[]')
                ? `${move.toPath.slice(0, -2)}[].${move.key}`
                : `${move.toPath}.${move.key}`;

              if (node.path.startsWith(movedNewPathPrefix)) {
                // This node is under a moved parent, calculate original source path
                const suffix = node.path.slice(movedNewPathPrefix.length);
                sourcePath = move.originalPath + suffix;
                isMoved = true;
                break;
              }
            }

            paths.push({
              path: node.path,  // New display path (for output structure)
              sourcePath: sourcePath,  // Original data path (for getting data)
              key: node.key,
              originalIndex: node.originalIndex,
              order: orderCounter.value++,
              isMoved: isMoved
            });
          }
          if (node.children) {
            node.children.forEach(c => collectSelected(c, paths, orderCounter));
          }
          return paths;
        }

        // Build nested structure expression that preserves hierarchy
        // Paths are already in tree order (after drag reordering)
        function buildNestedExpr(paths) {
          // Check if we have any moved nodes - need $root binding
          const hasMoved = paths.some(p => p.isMoved);

          // Parse each path into segments, keep original order
          const parsed = paths.map((p) => {
            // Parse display path for output structure
            const displaySegments = [];
            let current = p.path.slice(1); // remove leading dot

            const regex = /([^.\[\]]+)(\[\])?\.?/g;
            let match;
            while ((match = regex.exec(current)) !== null) {
              if (match[2]) {
                displaySegments.push(match[1] + '[]');
              } else {
                displaySegments.push(match[1]);
              }
            }

            // Parse source path for data extraction
            const sourceSegments = [];
            let sourceCurrent = p.sourcePath.slice(1);
            regex.lastIndex = 0;
            while ((match = regex.exec(sourceCurrent)) !== null) {
              if (match[2]) {
                sourceSegments.push(match[1] + '[]');
              } else {
                sourceSegments.push(match[1]);
              }
            }

            return {
              displaySegments,  // For output structure
              sourceSegments,   // For data extraction
              key: p.key,
              path: p.path,
              sourcePath: p.sourcePath,
              order: p.order,
              isMoved: p.isMoved
            };
          });

          // Separate array paths from non-array paths (based on display structure)
          const arrayPaths = parsed.filter(p => p.displaySegments.some(s => s.endsWith('[]')));
          const nonArrayPaths = parsed.filter(p => !p.displaySegments.some(s => s.endsWith('[]')));

          // Build tree structure with order info
          function buildTreeWithOrder(paths) {
            if (paths.length === 0) return null;

            const tree = new Map();
            paths.forEach(({ displaySegments, sourcePath, order, isMoved }) => {
              let node = tree;
              displaySegments.forEach((seg, i) => {
                if (i === displaySegments.length - 1) {
                  node.set(seg, { leaf: true, sourcePath: sourcePath, order: order, isMoved: isMoved });
                } else {
                  if (!node.has(seg) || node.get(seg).leaf) {
                    node.set(seg, { children: new Map(), order: order });
                  }
                  node = node.get(seg).children;
                }
              });
            });
            return tree;
          }

          // Convert tree to jq expression with proper value extraction
          function treeToExpr(tree, useRoot = false) {
            if (!tree || tree.size === 0) return '';

            const entries = Array.from(tree.entries());
            // Sort by order to preserve drag reorder
            entries.sort((a, b) => {
              const orderA = a[1].order ?? 0;
              const orderB = b[1].order ?? 0;
              return orderA - orderB;
            });

            const parts = entries.map(([k, v]) => {
              if (v.leaf) {
                // Leaf node: extract value from source path
                // Use $root for moved nodes
                const prefix = (v.isMoved && useRoot) ? '$root' : '';
                return `${k}: ${prefix}${v.sourcePath}`;
              } else {
                // Nested object
                const inner = treeToExpr(v.children, useRoot);
                return `${k}: ${inner}`;
              }
            });

            return `{${parts.join(', ')}}`;
          }

          // Handle array paths - group by array base, preserve order
          // Build nested tree structure for fields within array
          function buildArrayExpr(paths, useRoot = false) {
            const groups = new Map();
            paths.forEach(({ displaySegments, sourceSegments, sourcePath, order, isMoved }) => {
              const arrayIdx = displaySegments.findIndex(s => s.endsWith('[]'));
              const baseParts = displaySegments.slice(0, arrayIdx + 1);
              const base = '.' + baseParts.map(s => s.replace('[]', '')).join('.') + '[]';
              const rest = displaySegments.slice(arrayIdx + 1);

              if (!groups.has(base)) groups.set(base, []);
              groups.get(base).push({ rest, sourcePath, order, isMoved });
            });

            const exprs = [];
            groups.forEach((items, base) => {
              // Sort by order first
              items.sort((a, b) => a.order - b.order);

              // Build a tree structure for nested fields
              const fieldTree = new Map();
              items.forEach(({ rest, sourcePath, isMoved, order }) => {
                if (rest.length === 0) return;

                let node = fieldTree;
                rest.forEach((seg, i) => {
                  if (i === rest.length - 1) {
                    // Leaf node
                    node.set(seg, { leaf: true, sourcePath, isMoved, order });
                  } else {
                    // Intermediate node
                    if (!node.has(seg)) {
                      node.set(seg, { children: new Map(), order });
                    }
                    const existing = node.get(seg);
                    if (existing.children) {
                      node = existing.children;
                    }
                  }
                });
              });

              // Convert field tree to jq expression
              function fieldTreeToExpr(tree) {
                const entries = Array.from(tree.entries());
                entries.sort((a, b) => (a[1].order ?? 0) - (b[1].order ?? 0));

                const parts = entries.map(([key, val]) => {
                  if (val.leaf) {
                    if (val.isMoved) {
                      // Moved field: use $root to get from original path
                      return `${key}: ${useRoot ? '$root' : ''}${val.sourcePath}`;
                    } else {
                      // Normal field: use relative path
                      return key;
                    }
                  } else {
                    // Nested object
                    const inner = fieldTreeToExpr(val.children);
                    return `${key}: ${inner}`;
                  }
                });

                // Check if all parts are simple field names (no colon)
                const allSimple = parts.every(p => !p.includes(':'));
                if (allSimple && parts.length > 0) {
                  return `{${parts.join(', ')}}`;
                }
                return `{${parts.join(', ')}}`;
              }

              // Get parent path (before [])
              const arrayIdx = base.lastIndexOf('[]');
              const parentPath = base.slice(0, arrayIdx);
              const parentSegments = parentPath.slice(1).split('.').filter(s => s);

              let innerExpr = fieldTreeToExpr(fieldTree);

              if (parentSegments.length === 0) {
                exprs.push(`[.[] | ${innerExpr}]`);
              } else {
                // Build with parent structure
                let result = `[${base} | ${innerExpr}]`;
                for (let i = parentSegments.length - 1; i >= 0; i--) {
                  result = `{${parentSegments[i]}: ${result}}`;
                }
                exprs.push(result);
              }
            });

            return exprs;
          }

          const results = [];

          if (nonArrayPaths.length > 0) {
            const tree = buildTreeWithOrder(nonArrayPaths);
            results.push(treeToExpr(tree, hasMoved));
          }

          if (arrayPaths.length > 0) {
            results.push(...buildArrayExpr(arrayPaths, hasMoved));
          }

          // Merge results
          let finalExpr;
          if (results.length === 1) {
            finalExpr = results[0];
          } else if (results.length > 1) {
            // Merge using * operator for objects
            finalExpr = results.join(' * ');
          } else {
            finalExpr = '.';
          }

          // Wrap with $root binding if needed
          if (hasMoved && finalExpr !== '.') {
            finalExpr = `. as $root | ${finalExpr}`;
          }

          return finalExpr;
        }

        function updateExpression() {
          const selected = collectSelected(tree.value);
          if (selected.length === 0) {
            expression.value = '.';
            runQuery();
            return;
          }

          expression.value = buildNestedExpr(selected);
          runQuery();
        }

        function expandAll() {
          function expand(node) {
            if (node.children) {
              node.expanded = true;
              node.children.forEach(expand);
            }
          }
          expand(tree.value);
        }

        function collapseAll() {
          function collapse(node) {
            if (node.children) {
              node.expanded = node.path === '.';
              node.children.forEach(collapse);
            }
          }
          collapse(tree.value);
        }

        async function runQuery() {
          try {
            const res = await fetch('/api/query', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                data: rawData.value,
                expression: expression.value,
                format: format.value
              })
            });
            const data = await res.json();
            if (data.error) {
              error.value = data.error;
              result.value = '';
            } else {
              result.value = data.result;
              error.value = '';
            }
          } catch (e) {
            error.value = e.message;
          }
        }

        function copyResult() {
          navigator.clipboard.writeText(result.value);
        }

        onMounted(() => {
          tree.value = buildTree(rawData.value);
          runQuery();
        });

        watch(format, runQuery);

        return {
          tree, result, error, format, expression, dragEnabled,
          toggleNode, selectNode, handleReorder, handleMoveInto, expandAll, collapseAll,
          runQuery, copyResult
        };
      }
    }).mount('#app');
  </script>
</body>
</html>
